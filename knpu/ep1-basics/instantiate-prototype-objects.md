# Instantiate Prototype Objects

We are finally about to dive into prototypical inheritance, real JavaScript instantiatable objects. But first, let's do just a little reorganization on the Helper object because it will make the next thing we do a little more obvious. Instead of putting all of my functions directly inside my object once, I'll just say var Helper equals open curly closed curly, and then Helper.Initialize equals function, and Helper.CalculateTotalWeight equals function and that's it. Notice this didn't make any changes. This is just a different way of putting keys on an object.

I didn't do this for any special reason. It just makes what we do next a little bit nicer. Now in JavaScript everything is an object. Obviously Helper is an object, but we already saw earlier that functions themselves are objects. Let me call this.HandleRepLogDelete. That is a function that has a method called bind on it. Even strings are functions as we are going to see in a second. The only downside with our object so far like Helper is that they are static.

Now JavaScript doesn't have an idea of static versus non-static, but effectively they are static because they can only have one helper object. If I had two areas on my page that I wanted to calculate the total weight for it. I can crate two helper objects so if I can't initialize a second time it will override the wrapper on the first one. It acts like a static object. That's what we need to fix. I want to be able to create objects in PHP like we do with the new keyword, where we can create five new objects and they all have their own properties.

How do we do that? Well by setting your helper not to an open curly, close curly object, but instead setting it to a function. I replace my initialize key with a function, so helper now is actually a function, but of course functions are objects so it is still okay to add properties to it. That may seem weird but as soon as we do this, when we use Helper we can actually this.Helper equals new Helper and pass a wrapper. JavaScript does have the new keyword just like PHP and you can use it once helper is actually a function.

Now of course when we call new helper, it is going to execute our constructor because that's what this is now. It is a construct function. Now instead of using the Helper sort of statically, we will say this.Helper. We use that instance of that object. Now already this is better because we can instantiate multiple Helper objects and each of them will have its own wrapper property and we will do that in a second. First let's try this. Go back. Refresh. Let's delete one of our items, and it did up here but the total didn't update and we have an error.

This.helper.calcualtetotalweight is not a function. In other words, instead of a repLog when trying to call our function, it doesn't work. This.helper.calculatetotalweight is not a function, but down here we can see CalculateTotalWeight is a function. What the heck is going on? To find out up and initialize, let's log a few things. Let's consult that log this.helper and then object.Keys This.Helper object. This lets you print the helper object and then object.key lets you print the individual properties and methods inside of Helper. It is a nice way to see what methods you can call on that object.

We will do the same thing for Helper and Object.keys Helper. Let's look at what the difference is between our instance of the Helper object and actually pointing directly to the Helper object itself. Let's go back, refresh, and check this out. Inside the console, we see our Helper object is being printed but check this out. The methods on it are just, the keys on it wrapper. We can see it in both spaces here. In other words, the Helper instance this.Helper after there is a new helper, it does have a dollar sign wrapper property. That's cool, but it does not have a calculateTotalWeight property on it.

That's why we are getting the error. Question is why? Down in the second, we actually print out the upper case 'H' Helper object, you'll see that it prints out and it actually says I'm function which it is, but then we print Object.Keys, it has a key called calculateTotalWeight. This can be very confusing. At this point, the calculateTotalWeight function is still basically static. The only way that we can call the calculateTotalWeight function is by saying Helper.calculateTotalWeight. We cannot say This.Helper.CalculateTotalWeight, we cannot call the method on the instance of it. It just doesn't work.

To fix this instead of saying Helper.calculateTotalWeight, you need to say Helper.Prototype.calculate.Weight. As soon as we do that, you'll now see ... Hi guys [crosstalk 00:08:10]. As soon as we do this anywhere, I'll do it up in initialize, we can call this.Helper.CalculateTotalweight. Let's go back, refresh, and now immediately you see 157.5. The short explanation is that when you create objects that need to be instantiated, you need to add the properties and methods on it on to this prototype key.

Then when you have a new Helper magically the CalculateTotalWeight becomes available on that object, but there is a little bit more to it than that if you are interested. If you go back and look over here, look at our Helper instance still only has dollar sign wrapper. You do not see our calculateTotalWeight. How the heck is that working? We will check out this underscore underscore proto underscore underscore. Every object has a magic property called underscore underscore proto underscore underscore.

If you open it, it has a calculateTotalWeight function. When you call a function or access a property on an object, JavaScript first looks for it on the object itself. If it doesn't find it, it looks inside the underscore underscore proto underscore underscore to see if it is there. If it is, it calls it uses that. If it is not, it actually keeps going to the next underscore underscore proto underscore underscore and tries to look for it there. What you are seeing here is actually the proto methods that are available to every object in JavaScript.

It is almost like the top level object. It is almost like the top level class in a normal class inheritance system. When you set the prototype property, include a new instance of the Helper Object, anything on the prototype becomes the underscore underscore proto on that new object. Let's play with this a little bit. Normally let's create a new variable called play object, and we will send it to an object with a lift key set to stuff. Then we will say playObject dot  underscore underscore proto underscore underscore dot Cat equals meow.

Now you shouldnâ€™t normally access or set the underscore underscore proto underscore underscore property, but just to see how things work it is okay. Now say consult that log. Play Object.lift, which we know obviously work. We can also say PlayObject.Cat. Let's go back, refresh that and check that out. Stuff and Meow. That is prototypes in action. Remember how I said everything is an object in JavaScript? That means you can actually say you can look at the proto for anything. Let's do consult that log and let's take fu, which is a string and let's check this out.

Dot underscore underscore proto underscore underscore. How about let's look at what the proto looks like for an array? Left square bracket, right square bracket dot underscore underscore proto. How about a new date object dot underscore underscore proto underscore underscore? Let's go back and refresh. What you are seeing on each of these are the methods that you can call on each of them. String as an index up method, and also has a match method, has a normalize method, has a search method, a slice method. Same thing with the array. Array has all of these methods on it.

The date has all of these methods; get hours, get milliseconds, get minutes. In fact let's Google for JavaScript string methods. If you check out the W3Schools here, this is going to give you basically the same information that I just was. All of these methods that you can call on string. We now understand that the way that works is that those are stored on the underscore underscore proto of every string. Ultimately this allows us to have multiple instances of our helper object. You just need to understand how the prototype works say to take advantage of it.

For example we can say Var Helper2 equals new Helper and pass it a different wrapper like for example the footer on our page. The footer doesn't have any rows that have a weight on it, so that will probably be zero. We can say console that log this.HelpercalculateTotalWeight and Helper2.calculateTotalweight. Go back and refresh. We get 157.5 and of course we get zero. This is a little bit difficult to understand. The lesson is this. You do want to create objects that you can instantiate.

When you do that, you need to set them to a function, so that you have a constructor. Then add every method and property that you want to put on that object you need to put on the prototype. You are still allowed to add keys directly to Helper, but if you do that they effectively become static. You can only call them via Helper.fu or Helper.bar. Let's keep going with this and organize this a little bit and also turn a repLogapp object into a properly instantiatable object.
