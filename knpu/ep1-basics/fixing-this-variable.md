# Fixing This Variable

In phpcov, when we call a function like we call our updateTotalWeightLifted function, we expect this variable instead of that function to be whatever object we're inside of right now. In that case, it is. But in so many other cases, we're finding that this is actually something different, like when the handleRowClick is called down here or when the handleRepLogDelete is clicked, this is something different.

It turns out, in JavaScript when you call a function, you can choose to change what this is inside of that function when you call it. So that means you can have one function technically, and 10 different people could call your function and decide to set this to 10 different things.

Now, in reality it's not that bad. The name of the game is, whenever you have a callback function, meaning someone else is calling a function after something happens, this will have changed. We see this a bunch of times on our click functions. We also saw it inside the .each function. Our callback in there, this is different. Down here also in the success function. We're not using this right now, but this is different. Even inside our row.fadeOut. Once the fadeout finishes, our callback function is called and this is something different. What is this? Well, it depends on the situation. So you need to read the docs for the success function, for example, or the fadeout function, or the .each function, to figure out what this is. For example, in the case of fadeout, this ends up being the element that just finished fading out. So we can call this.remove and it has the exact same effect as before.

Let's play with this a little bit. I want to create a new function just for debugging called whatIsThis and give it a single argument, a greeting. Inside, we're just going to call console.log, this. We'll also print out our greeting. This will help us figure out what this is. Then in the bottom of initialize, we'll say this.whatIsThis and pass it hello. Cool.

We're calling this function directly. It's not a callback function, so I would expect this to actually be our RepLogApp object. Let's find out. Refresh. If you expand your object, it is our RepLog object. Cool.

Now, check this out. If we want to, when we call this function, we can change what this is. So I'll create a new function, new variable called var newThis and I'll set that to an object with cat, meow, and dog, woof. Remember, this is an object because associative arrays are objects in JavaScript. To change this, instead of calling the function directly, we're gonna say this.whatIsThis.call and pass it new this, and greeting, and hello. Now, a real quick note, this.whatIsThis is a function. In JavaScript, functions are actually objects so you can call methods on functions themselves. The function object happens to have a method on a call, call. The first argument is the new this variable and the second, third, fourth arguments, and so on are the arguments you want to pass to that function.

Let's refresh now and check this out. This is now our cat, meow, dog, woof objects. That is what is happening behind the scenes with your callback functions.

So how do we fix this? Because if we're going to be fancy and have objects in JavaScript, I don't want to have to worry about my functions having this changed. I want to know confidently that my whatIsThis function, that this inside is my RepLog object. Same thing down here with our callback functions. I want to know that when I ... Inside handleRepLogDelete, this is my object, not something else. I want this to behave more like a normal object. Well, the way you do it is by using the bind function. So let's create a new variable called var boundWhatIsThis equals this.whatIsThis. Don't call that function, but call another function on it called .bind, this. That is another function you can call on any function. You pass it what you want this to be, which in this case is our RepLogApp object, and it returns a new function that, when called, will always have this variable set to whatever you pass to bind. Now, we could say boundWhatIsThis.call. We're still passing it new, this, but it's going to be ignored. Refresh and once again, it's back to our this object.

This is great because it gives us a way to guarantee that our functions have a normal this. We just need to make sure that they're bound. Delete that debug code. In practice, it means whenever you have an event listener, you're going to want to call .bind, this. I'll do it on both of our event listeners. That returns a function, who will always have the correct this object.

Now, of course, the only problem is that we're relying on this down here to be our clicked link. It's hard. We kind of want this to be two things at once, but that's fine because we already know that this inside of a DOM listener function is equal to e.currentTarget. So we can say, var $link equals $(e.currentTarget). Now we just change all of our dollar sign, open parentheses to link. And life is good down here.

Now we have the opportunity if we want to, to actually use the this function in here to call other functions inside of our object. Now, there's one other change I want to make, but ... Let's try it. Refresh, click, and we're good to go.

The last thing I want to fix is ... Down here, we'll still referencing the RepLogApp object. I would like to use the this variable now, and the reason is I described this object we have here as sort of a static object. And that's true, but that's not going to be true forever. Eventually, I'm going to show you how to create objects that you instantiate, meaning we could have many RepLog objects. We could have maybe five tables on our page. We instantiate five different RepLogApp objects for our five different tables. In that case, we don't want to reference RepLogApp anymore because we might have five of them. It doesn't make sense. I want to be able to use this, which will point to this RepLogApp object.

Now, of course, the problem is we know that this down here is not going to be this object. How could we fix this? Well, there's two options. One is we could bind our success function here to this. That way we have this inside of it. Then we could bind our fadeout function to this. Then we'd be able to call this.updateTotalWeightLifted or something like that. But it gets really ugly and it's not really necessary. If I have inline callback functions like this, because I could refactor this to an actual method on my object, the easier way to do it is when, above, when you know that this is still our object, you can say var self equals this. Since this self variable is just a variable we invented, it doesn't change inside your callback functions and you could say self.updateTotalWeightLifted. If you want to refresh that, it works fine. So that's a little kind of a hack, but it's a good trick so that you don't have to get too crazy with this binding stuff.
