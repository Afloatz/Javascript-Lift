# All About Promises

There's one last really important concept in modern Javascript that I want to talk about right now. It's called 'promises'. We all know that in Javascript a lot of things happen asynchronously. For example, Ajax calls happen asynchronously, but even more than that, fade out happens asynchronously. We call the function but it doesn't finish until later. This is so commonplace that Javascript has actually created an interface to standardize how this is handled. If you understand it, it's really going to make you powerful.

The idea is all about being able to execute some functionality and systematically run some code once that asynchronous operation finishes. Google for 'Javascript promise' and click into the Mozilla.org article. It turns out to handle this there is a promise object in Javascript. It's literally in plain, normal Javascript. There's some browser compatibility promises. We'll talk about that in a little bit.

This article talks about the two different reasons that you would use a promise. The first reason that you would use a promise is that you are actually the one that is executing the asynchronous code. That would be creating a promise. We don't do that very often, though we are going to talk about how. The second use case for a promise is that someone else is doing something asynchronously, like an Ajax call, and you want to do something once it finishes.

Whenever something asynchronous happens there are two states. Either that thing finishes successfully or it fails. In promise language we call that the promise being fulfilled or the promise being rejected. If you look down in this code block, I want you to ignore the creation of the promise. Look down here to this 'then' method. The idea is that if something happens asynchronously like an Ajax call, they would return to you this promise object and you could call '.then' on it and pass the function that you want executed once that operation finishes successfully.

Now that we know that, Google for 'J Query Ajax', the '$.Ajax' function that we've been using. Check this out. Normally when we call '$.Ajax', we don't think about what value this function returns. I'm not assigning it to anything right here. You can see that it actually returns something called a 'JQXHR'. On this page, if you search for the 'JQXHR object', you'll find a little header that talks about it. Says, 'this is an object returned by $.Ajax', and it has a bunch of methods on it to help you with your Ajax call, but more importantly, look down here. 'The JQHXR returned implement the promise interface giving them all the properties, methods, and behavior of a promise.' In other words, what we get back from '$.Ajax' is an object that has all the functionality of a promise.

Before we talk about that more, below here it shows you all of the different functions that you can call on the JQHXR object. You can call 'done', which is an alternative to the 'success' call back, or '.fail' which is an alternative to the 'failure' call back, and check this out, not surprisingly you can call '.then' because 'then' is the method that actually exists on the promise object.

Let's actually see what this means in action. You find your handle new form submit, it means that '$.Ajax' returns this JQHXR object which has a '.done' method on it. We can say '.done', give it a data argument, because '.done' will receive the same argument as success. Let's say, 'console.log I am successful'. Let's also 'console.log data', but now we can just chain another one off of there. The nice thing with promises is that you can have multiple handlers for a promise. We'll 'console.log data' here as well. If you go back and refresh, now add something and check out both of our handlers right here.

Effectively J Query returns us an object that has all the functionality of a promise plus a few additional methods. The only methods that a true promise has on it are 'then' and 'catch' for when something is rejected, but this object has additional ones like 'always, fail, done' and others that you can see inside of something that they call their 'deferred object'. The story here is that J Query implemented this functionality before the promise object was standard in Javascript. You can use all of these methods, but instead I want to focus on treating what we get back from J Query as a promise object. I want to pretend that these other methods don't exist and stay very standard and just use the '.then' and the '.catch' methods. Very simply, I'm saying, 'don't rely on .done, just use .then', which is the method you would use with any other promise coming back from any other library because it is the standard.

If we go back and refresh now, we can submit and we still get our two handlers, but check this out. Our first data printed out is the correct data, but our second one printed out is undefined. If you look back at the promise documentation, this actually makes sense. It says that, '.then appends fulfillment handler on the promise and returns a new promise resolving to the return value of the recalled handler.' In other words, with '.then', whatever you return from '.then' ... If you think about this, when we call '.then' the second time, that's actually being called on the return value of this '.then'. With '.then' the values are chainable, meaning whatever you return from the first '.then' is going to be passed as the value for the second one. Now I need to return data. This time it works out perfectly again. The fact that you can pass the value forward is actually very powerful because you can change the data with your chained '.then' and we'll see that.

What about handling failures? As you can see on the promise documentation, the '.then' actually has a optional second argument which is a function that will be called on failure. In other words, we can actually go to the end of our '.then' here, say, 'function', and we know that our error is going to be passed 'JQHXR'. We'll console.log, 'failed'. We'll also console.log, 'JQHXR.responsetext' to make sure that's still working. Go back and refresh now, keep the form blank, hit 'submit', and you can see it our fail handler and it printed our error response back which is perfect.

The second way, and actually the better way, however, to handle rejections, is actually to use this '.catch' function. It's identical, it's just a little bit cleaner. What I mean is, instead of passing a second argument, let's close up that function and then call '.catch' like this. When we do that, we have the exact same response as before. However, check this out. This was happening in both ways that we handled the '.catch' handler. Another handler is being printed out. In other words, our '.then' is being skipped because it's not successful, but after the '.catch', this '.then' is being executed. Why?

It turns out that you really need to think of '.catch' the same way you think of a 'try catch' in PHP code. It means that it will catch any of the errors that went above it. Once you've caught that error, your execution continues on like normal, means that that catch here has actually swallowed the error and then '.then' is run afterwards as if it's successful.

We're going to talk more about that, but what you probably want is your '.catch' to go on the end. Now the second '.then' is only going to be run if the first '.then' is executed, '.catch' will catch errors at the bottom. Refresh now. You just see the one failed running. With this new knowledge we can actually start refactoring our success and error callbacks to this new format.

It's easy. We can just copy our code from success into '.then'. Not worried about the return statement here because we're not chaining our 'then's. I'll get rid of our '.then' and then I will move our error callback into 'catch'. With any luck, that will worth the exact same way as before. Error looks good. Adding a new one looks good.

Let's find our two other '.Ajax' locations. Let's do the same thing there. With the 'success' function to '.done', and we'll move this '.success' function also to '.done'. Awesome.

One of the most powerful things about promises is that not only can you chain multiple promises onto things but it also means that you can refactor your asynchronous code into external functions. What I mean is, we can actually create a new function down here called, 'saved rep log' with a data argument. If we want to, we can move our Ajax code into that and then return it. I'll put the data to 'data'. For the URL, we can actually do 'routing.generate' to simplify things. 'Wrap log new'. I will just expose our new endpoint, it's Javascript.

The point is now, up here, we can simply call 'this_saved rep log' and pass it 'form data'. Isolating asynchronous code like this wasn't possible before because we needed to pass our success and failure handlers as options to our '.Ajax', but now I don't need to do that. We can just call a function and we know that that function returns a promise. We know that promises have a '.then' method and a '.catch' method on it. If we need to save a rep log from somewhere else on our code, we can do that. We can call 'saved rep log' and we can even attach new functionality that happens when it's successful.

Next, let's look what happens when things get more complicated and we need to create our own promise objects.
