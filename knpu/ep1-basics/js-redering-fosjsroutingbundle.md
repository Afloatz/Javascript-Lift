# JS Rendering FOSjsRoutingBundle

All right. It's working except we have some pretty ugly duplication between our client-side templates and our server-side template. This is a classic problem, and there are kind of two ways to fix it. The first way is, if you use Twig on the server-side like I do, there is a library called twig.js for JavaScript. So, in theory, you can actually have a Twig template like this for your server-side and then you can actually reuse this template on the client-side. I actually know people that do this and I have done it in the past. It works really well and you're welcome to go that route. It allows you to continue to render some templates on the server-side and some templates on the client-side. My only advise is that you keep your templates very, very simple. Don't use too many filters, like the trans filter, or deep variables. Keep everything very, very simple.

The second way, and the more universal way, is you need to stop rendering things on the server-side. As soon as I have a client-side template, well this has to live in the client-side in order for us to dynamically update the page. So to remove the duplication, we really need to remove the server-side template and render all of our rows via JavaScript. Inside of our object, let's add a new function called loadRepLogs. What we're going to do is, when our object is initialized, we're going to call loadRepLogs, it's going to make an Ajax call back to our server which will return an array of all the current RepLogs and then we will build the rows dynamically using that data. This endpoint is already created. It's /reps and it returns an array of RepLog data. We'll look at what that data looks like in a second.

So the question is, How do we get this URL inside of JavaScript other than just hard-coding /reps? Well, there are three ways that I can think of. One is we could use a data- attribute. For example, we could go on the DOS and wrapper elements inside of index.html.twig and we could add a data-reps-list-url element and then read that inside of our JavaScript. A second way is that we could actually pass it as a second argument to our constructor, so we could generate the URL down here and pass it as a second argument to RepLogApp and then set that on a property the same way we do wrapper, with the second argument to that function. This is also a really, really good option.

A third option, especially when you're in Symphony, and kind of a lazy option, is to use a cool library called FOSJsRoutingBundle. Google for that, and click the link on the Symphony.com documentation. This is Symphony specific, but what it does is it allows you to expose some of your URLs to JavaScript, so I'll copy the composer required line, open up a new tab, paste that, and then, while we're waiting for that, we'll finish the installation instructions which are adding the new bundle to AppBundle, AppKernel. We also need to import some routes into our routing.yml file, app/config/routing.yml, and then finally we need to add two script tags to our page. And this will go in our base.html.twig. What this bundle does is it exposes a global variable called routing. Just remember that. It's a global variable. That's very important. And you can use that routing variable to generate links in the same way that we use the path function on the server-side to pass the route name and parameters.

Once that's done installing ... Perfect. I'm going to our RepLog controller and in order to expose this and make it available on the client-side, we gotta little option called options={expose=true}. Now back in JavaScript, to use that, remember this library gives us a global routing object, and of course, inside of our self-executing function, we have access to any global variables, but as the best practice, we prefer to pass ourselves any global variables that we're using. So I'm actually going to pass ourselves that global routing object and we'll add a routing argument up here. Down in loadRepLogs, we can now simply do a DOS and Ajax the URL set to Routing.Generate and then the name of our route name rep_log_list. And on success, let's dump that data. See what it looks like. Let's go back. Refresh. Let's lift a big fat cat and awesome. Check this out. 24 items, there's an items key, and then each item in there has the exact same keys as we're getting back from our add endpoint, ID, item label, links, rep, total weight lifted. All the variables that we need to pass into our AddRow function.

So we're ready to go. In fact, let's go back to index.html.twig, find your <tbody> and let's clear this out. We do not need to render this stuff on the server-side anymore. In fact, we can even delete our RepRow template entirely. And inside of LiftController, which renders this index, that html, that twig page, we don't need to pass in replogs or really totalweight anymore, 'cause even the total weight down here, we're already handling that in JavaScript so we don't need to print that variable either. So, if you refresh the page now, we've got a totally blank form that's waiting for our JavaScript to actually fill that in, and at this point guys, very simple. We'll just loop over data.items and each of those is going to be a repLog object. Involve Ajax we can say var self = this and then self._addRow(repLog) and that should do it. Refresh the page. Slight delay. Boom! All of 'em go in perfectly. We can delete 'em. We can add new ones. It's perfect.
