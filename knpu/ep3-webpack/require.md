# Require

Hey, guys. Welcome, finally, to our tutorial on Webpack. We've packed a ton of stuff into this. Seriously, Webpack is a game-changing tool for the front-end Javascript world. It's also one of the most difficult to learn tools that I've tackled in years, and I don't want you to go through that same process. So we are going to learn Webpack from the bottom up and then, you are going to have an amazing, earth-shattering new tool at your fingertips.

What does Webpack do? Well, I'll show you in a second. But, I will tell you that it will change the way that you write Javascript, finally allowing you to write truly modular, professional code, just like you would in PHP.

Like always, code along with me by downloading the [inaudible 00:01:08] from this page. When you unzip the file, you should find a start directory that has the same code that you see here. If you've been coding along so far, use the new code because I've made a few tweaks since the last tutorial to help make our examples better. Then, follow the Read Me file for all the setup instructions to get your project going. The last step will be to find your terminal, move into the project, and run ./bin/console server:run to start the built-in PHP web server.

Then, we pull that it up on our browser as localhost:8000. Our app is, of course, Pump Lift Stuff. Log in with Ron Furgundy, password pumpup. This is our amazing app to keep track of all of the heavy things that we've been lifting throughout the day, so we can stay in shape. We've a fairly fancy front-end section that we've been working on in the previous two tutorials and now we're going to revolutionize the way that we wrote the code that runs this page.

In the last tutorial, in addition to running Javascript for the browser, we actually wrote a bit of Javascript that is actually node.js code. We had a little play.js file where we were using to try out different things, in this case, the set feature from ES6. Whenever you want to execute a node.js script, you can just say node play.js. Awesome. One of the most common things that you see when you use node.js code is the require key, which is at first very similar to the require key in PHP. It allows you to separate your code into files, check this out. At the root of your project, create a new foods.js, then, I'm going to copy in the foods code, delete it, put it in foods.js.

Now as you're probably expecting, we're going to require foods.js from play.js, and that's true. One important difference between the way it works in node and PHP is that in node, you need to explicitly export a value from a file. Whereas in PHP, we simply require a file, and whatever functions or classes are in that file, we automatically get. Instead of that happening automatically, in node.js, we would use a special keyword called "module.exports = foods." So when someone requires this file, the value that they're going to get is actually our foods set. In play.js, we can say, "const foods = require./foods." Now a couple of interesting things. Before we talk about it, let's try it.

Head back over, and it still works perfectly. Now notice I don't need a .js on the end of here, that's assumed. You can put a .js, but if you don't, it looks for a foods.js. The other thing is this dot slash is important. When you start with a dot ... node knows that you're looking for a file relative to this directory. If we just said foods without a dot slash, that means something different. We'll talk about that later. This is an awesome feature. The question is, can we get this in the browser Javascript world? Because this would be amazing. We could actually write many Javascript files, and use the require statement to pull them all together, and truly organize our code. The answer is no, but with Webpack, yes. First, I'm going to open up the template that runs our main page here. And at the end of the last tutorial, we actually started generating a dist file. We used a tool called Babble that read our source file, replogapp.js, and then transpiled it to this dist file. We're going to do that again, but for now, I want to delete the dist file, and point back to our source file.

We're now reading just our normal source file right here. Inside our replogapp, we actually have two classes. Near the bottom, we created a class called helper. For organization, I'm now going to separate this into its own file. In the same directory as replogapp, operate a new replogapphelper.js. [inaudible 00:06:32] use strict on top. Paste the class. Then at the bottom say, "module.exports = helper." Then in replogapp, now that that helper variable is gone, obviously we're not going to have a good time. You can see on line 10, element is not exported, which is a funny way of saying the variable does not exist. At the top, I'll say, "const Helper = require./replogapphelper." The error goes away. Based on what we just saw in node.js, this should work, and it makes perfect sense. Of course if I do inspect element, go into my console, and refresh, as you're probably guessing, we get a different store. Require is not defined.

Browsers support almost all features in the ... this is not just because browsers haven't caught up. Browsers can't define the require key. It just doesn't make sense. In PHP, when we use the require key, we're reading a file from a file system, which is practically instant. That file is read synchronously. In the web world, the only way for our browser to get weblogapphelper would be to make an ajax call, which is asynchronous. If the browser waited for that file to be downloaded, our page would take forever to load. Can you imagine our page loading, then one Javascript file downloading five other Javascript files, then waiting for those Javascript files to load more Javascript files? It would be a disaster. The require key is just not possible to implement in a browser. That's where Webpack comes in.

