# Bootstrap Font Awesome

In our base layout, base.html.twig, I want to remove all of the style sheets and require them properly. So, we only have two left: Bootstrap and Font-Awesome. So, let's remove Bootstrap and instead, in layout.js before main.css, because we want to load Bootstrap CSS first, let's add a "require" key. But, what do we put here?

We already know that we installed Bootstrap via Yarn and this is how we can require the bootstrap.js file, but how can we require that Bootstrap CSS file? Does that package even contain the CSS or does it just have a JavaScript? Well, just like with SweetAlert, to find out, open your Node Modules directory, find Bootstrap, and look inside.

Yeah, okay, this also has a dist directory with CSS in bootstrap.css. So, just like before, we can say "bootstrap/dist/css/bootstrap.css". These cases, we don't need to worry about requiring a minified file because eventually, we're gonna have webpack minifier CSS files for us. So, this makes perfect sense, when you require something that doesn't start with a dot, it looks in your Node Modules directory for a Bootstrap directory and then we can just have whatever file name we want after that.

But then, how does this work? When we just say "bootstrap", what does that do? Does it look for an index.js file in this directory? Well, there isn't one, so how does that work? The secret is that inside of the package.json file for that library, it should have a key called "Main". Not all libraries have this; there are a few old legacy libraries that don't, but most new libraries have this "Main" key. This is what tells Node which file to include when you just require the name of the module. So, in this case, when we just say, "require bootstrap," it actually requires "dist/js/npm.js". That's the secret behind how that works.

Alright, so I'll close the package.js file, package.json file, and head over and refresh the page. Whoa! That did not go well! We check out the console. Ah, we have a very familiar error. "Module parse failed" for "fonts/glyphicons-halflings-regular.eot Unexpected character." So, just like a second ago when we tried to load an image file, in this case, somewhere deep in Bootstrap, it's trying to load a font file and it's having the exact same problem.

Back in our Asset Management tab on Webpack, there's a link for loading fonts and it's the exact same thing as loading images. Add a loader for the extensions for fonts. So, let's do that. In webpack.config.js, I'll copy our image loader, and this time I will use their test key exactly.

Excellent. So, let's go back ... Let's go back to our terminal, find our Watch tab, get rid of all this ugly stuff, and then restart it since we just modified our webpack.config.js file, and it's happy! And if we close our Node Modules for a second and go to the Web Build directory, ha! We have a bunch of new files. We still have our png, but we have a bunch of font files, too. And, of course, we're gonna refresh. Everything is back to normal. I'm not using any of the Glyphicons on a page, but if we were using them, they would totally work.

So, there's one last link tag to get rid of and it is Font-Awesome. So, let's kill that link tag and I'll close up my Stylesheets block. And we don't have Font-Awesome installed yet, so I'll go to my last terminal tab and run "yarn add font-awesome --dev." That's the name of the official Font-Awesome package.

Then, in layout.js, after Bootstrap before main.css, we'll say, "require font-awesome/," then to get the correct path here, once again I'll open up Node Modules, find Font-Awesome, and yes! We can say "css/font-awesome.css". And without doing anything else, want to refresh. It works! This little icon here is coming from Font-Awesome and so is this icon here. And the trash icon.

And if you close up Node Modules and look at your website's build directory, wow, it's really getting crowded! We now have fonts from Bootstrap and also from Font-Awesome. It's not really important, but we can't really tell which fonts and which files are which. We don't really care but, you know, that's kind of weird.

Actually, one of the things you can do with the file load is you can control those file names. Right now, the file names are a unique hash of the image of the file. And that's great because it means if you have two files with the same file name, they'll have unique hashes in this directory and they won't run into each other.

So, go back to the Webpack site and click back on "Loading Images". There's a link to the documentation on the file-loader. And it actually shows using the file-loader in the inline syntax, which we now understand. And you can see here, it looks like one of the options is called "name=" where you can control the name. And, like with our output, it actually gets us a couple of template holders that we can use like "name", "extension", and "hash" where we can even control the link of the hash.

So, check this out. In webpack.config.js, lemme get rid of the simple file-loader and we're gonna use the expanded syntax that we used earlier. That means we'll say, "loader: file-loader" and "options," and here I will pass the "name" option. And I'm gonna use "name", that will be the original name of the file name, "-hash" because we do want the hash in the file name, and then say ":6" so that it'll only include the first six digits of the hash, which is probably unique enough, and then ".ext".

This is totally optional but it's nice. So, I'll copy that and then put it down for my fonts as well. Okay, to see this in action, let's go back to our Webpack terminal tab, stop webpack, and then run "rm -rf web/build/*" to empty out that directory. Then, restart webpack. And now, the file names are a whole lot better. It doesn't make any difference to our application because Webpack is always building the CSS files with the correct paths, but it looks a little bit nicer for us and it shows off, once again, how to pass options to loaders.

