# Minify CSS

Compile your webpack in production mode with yarn production. We already know that this minifies our JavaScript but it does not minify our CSS yet. You can see everything is just fully expanded still. That makes sense because webpack handles JavaScript but it doesn't really handle CSS. It's our loaders than handle the CSS. Specifically the CSS loader has a minimize option that we can pass to it. But very typically you're going to see it done a slightly different way with a plugin.

This can be a little confusing so I want to show it. Down at the bottom of my plugins list, down inside my production loop, I'm going to say webpackConfig.plugins.push with new webpack.LoaderOptionsPlugin. To this we're going to pass minimize: true which is the really important one, and another one called debug: false. All right, so what the heck does that do?

This plugin passes these options to all loaders, which initially shouldn't make sense. If I want to pass a minimize option to a loader, I should just pass them to the loader, and that's correct. But in webpack version 1, the way that you configured loaders was a little bit different, and when webpack 2 and 3 came out, not all loaders were necessarily upgraded to allow you to pass options to them in the new way. Basically, this makes sure that you're passing minimize: true, which his the really important one, and also debug: false flag, which also seems like it might be important, to all of our loaders. In the future we'll probably get rid of this, but it takes care of passing the minimize: true to the CSS loader for us, which actually we're going to do ourselves in a second anyways just to be sure.

But if we just do that, rerun yarn production. If you scroll up, you can see now for example our login.css is only 5 kilobytes, and it is definitely minified. Of course, it still has these source map which is actually taking up more space than the CSS itself. We want to get rid of our source map in the production build. Actually, there are two opinions on this. Some people say that you should continue to output the source map in production, but use a different type of source map that outputs to a file so that it's not part of your actual production build.

I'm going to turn source maps off entirely inside of my production environment instead. On top of my file, to make this really easy, let's add a ... On the top of my file, I'm actually going to move up my settings that I created earlier above my loaders, then add two new ones. const isProduction = ... then I'll copy the inside of our if statement down below and paste that here. Another one called const useSourcemaps = !isProduction. Very simply, instead of the sourceMap true on all of our loaders, we'll just change that true to the variable. We've now disabled source maps for CSS in production mode.

Near the bottom, remember we also have the devtool option which adds source maps for JavaScript. So same thing, I'll say useSourcemaps and then we'll use the inline-source-map else we'll set source maps to false. Finally, down below in our if statement, I can use the simpler isProduction flag.

Check this out. Before we had 211 kilobytes for our layout.js and 712 kilobytes for our layout.css. Let's try it again. When that's done, scroll up. You can see our layout.css is much smaller. You notice the layout.js is actually not smaller and that's because it already didn't have source maps set in it due to the uglify plugin which removes extra comments.

Remember, we used the LoaderOptionsPlugin down here to pass minimize true. What we really wanted to do ... that was just a lazy way of passing that to our cssLoader which is really the one responsible for minifying CSS. If you Google for css-loader and find its GitHub page, and search on here for minimize, you'll see these are the options that you can pass to the CSS loader. Minimize is the key one. Very simply, I'm going to add up here minimize: isProduction just so we have the direct, real way of setting that option.

Okay, so we're done. We have removed source maps. We have minimized our JavaScript and our CSS. There's one last little detail that we want to take care of. Google for webpack defineplugin. This is a very interesting plugin. Basically it allows you to define constants in your code. If you scroll down a little bit, here's a really good example. Let's say that in your code, you actually want to know whether you are in production mode or not, because maybe you do more logging if you're in production.

In your code, you could use some constant called production, which you never set in your code. But then in your webpack config, you can use the define plugin to say that production should be set to true. What happens is webpack actually rewrites your code, so if you normally have if !production in your code, the final built code will say if !true because it will actually replace the value of production with true. It's actually going through our code and rewriting it. This is a really cool feature and you can use it, as the documentation says down here, for feature flags even.

We're going to use it in a slightly different way. Down at the bottom of our configuration, in the isProduction block, we're going to say webpackConfig.plugins.push and new webpack.DefinePlugin, passing to that 'process.env.NODE_ENV': JSON.stringify('production'). There's a couple things going on here. First of all, you always wrap the values in JSON.stringify with a define plugin because it does an actual perfect search and replace, so you need to make sure that your string is wrapped in quotes. JSON.stringify is a really convenient way to do that.

Sometimes when you use third-party libraries, in those third-party libraries, they will actually check for process.env.NODE_ENV and check to see if it equals production. They'll actually do the same thing we're doing in our webpack config file. Of course when you're running JavaScript in a browser, there is no process.env.NODE_ENV and so sometimes this can cause third-party code to run in development mode instead of production mode. For example, it might do more logging or it might do things a little bit less efficiently. By adding this, if some third-party library uses node environment, this will replace it with the string production. Effectively, you will have if statements that say if production === 'production', then do something. This is what we want.

In our code it won't make any noticeable difference. When you run yarn production one last time, you'll still see everything built in its smallest format. We have a ready-to-go production build.
