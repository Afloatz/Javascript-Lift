# Automatic Versioning

There's now only one big, obvious feature that we're missing: versioning. Because right now if I change something inside of layout.js, the dump layout.js will change but our users' browsers will cache the old version. We need to be able to bust cache when our files change. The most reliable and best way to do this is to actually change the filename. With webpack we can do this automatically and in a really great way.

At the top of our webpack config, I'm going to add a new variable called useVersioning just set to true. I'm doing this just so that we can disable versioning easily if we want to for some reason. There are two places in our code where we are controlling the filenames that are output. The first is under output, and this is what controls the JavaScript. I'm going to add useVersioning and if versioning is on, we are going to have the name be [name].[hash:6].js. That is another wildcard that is available to you in here and it is a hash based on the file's contents. This outputs just the first six digits of it.

The other place that we control the filename is down in the plugin section when we run ExtractTextPlugin. Here we'll now say useVersioning and we'll default to our [name].css, but if versioning is on, we will say [name].[contenthash:6].css. ExtractTextPlugin does something very similar but it calls it contenthash instead. That's it.

Let's flip over, find our middle Terminal tab and run rm -rf web/build/* to clear things out. I'm just going to run a yarn dev to build our dev assets one time. Check this out. Boom, instantly, all of our JS and all of our CSS have hashes on them. If we changed any of those files, it would actually dump a new hash, so a login with a different hash .js. Great, so whenever we make a file change, the filenames change.

Of course on our front end, these means we are screwed because somehow in our application, we need to change our link and script tags to something that actually has that hash in it. But the hash is always changing! What we need is for webpack to dump a map from the original filename to the current, hashed filename. That's called a manifest. Google for a webpack manifest plugin. This is a plugin that does exactly that. I'll copy the package name.

We'll go over and run yarn add webpack-manifest-plugin --dev. Perfect. Now over at the top of our webpack config, let's bring that in with const ManifestPlugin = require and then the library name. Then down at the bottom of our plugins, very simply, we're just going to say new ManifestPlugin and that's it. Before we make any other changes, let's go back to our webpack tab and rerun webpack. If you scroll up, the same files are dumped, but now we have a new file, manifest.json. This thing is perfect. It's a map from the original filename to the current hashed filename. If we can get our server-side code to read this map, we are in business.

One thing to notice is that any copied files, so things that we used in our CopyWebpackPlugin to copy to our static directory, those do not appear in here. That's something that might be added in the next version of the manifest plugin. It is possible to actually version the copied asset names, but even if you do that, they don't appear in the manifest file so it's not really much help.

Before we worry about getting our server to read this map file, I'm going to add one option to the manifest plugin called writeToFileEmit: true. What that's going to do is if you're using the webpack dev server, which normally does not write files to your physical filesystem, with that option it will at least write the manifest.json. That's going to be important because in our application, we're going to read that physical file so we can get the map.

All right, so how do we do this? Well, if you look in our base template app/resources/views/views/base.html.twig, whenever we reference a asset filename, we always wrap it in Symphony's asset function. Even if you're using Symphony, the fix for this is going to be really easy. Symphony has builtin support as of versioning 3.3 to read a manifest file and take this input filename and actually output whatever is the value for that.

To activate it, you need to go into app/config/config.yml and under assets, add a key called json_manifest_path. We're just going to point Symphony to that path. Here we're going to say %kernel.project_dir% ... it's a wildcard for the root of our project ... /web/build/mainfest.json. That's it. If you go back and refresh, it still doesn't work, but we're closer.

If you view the page source, you see it's still not matching it up, so what's going on here? When you use this json manifest path, it literally takes whatever string we pass here, build/layout.css, and looks in the manifest file for build/layout.css, but our keys are only layout.css. In order for this to work, we actually need to prefix all of these with build/. Fortunately, the plugin lets us do that with a new option called basePath build/. Rerun webpack.

Now check out the manifest file. Perfect. build/layout.css and that means when we refresh our application, yes, it uses the path perfectly. Built-in versioning and we don't have to worry about anything. Whenever we update our files, they're going to get new filenames and that's going to give automatically be used in our application.
