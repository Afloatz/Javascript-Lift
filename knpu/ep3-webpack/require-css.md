# Require CSS

When you type a really long username in the login page, you see an error. Check this out. In the login.html.twig template, we include the build/login.js, and we also include this login.css file. [inaudible 00:00:23] web, assets, css, login.css. Really, this css is necessary to make this page look correct. Even more than that, this special div that's added in JavaScript, it's actually styled using css from login.css. What I'm trying to say is that the login.js entry really depends on the login.css file, but right now we still need to remember to include login.css whenever we use login.js. I want to stop doing that. Instead, let's treat the login.css file like any other dependency. What I mean is, at the top, let's require it. Require ('../css.login.css'). Now, that might seem crazy to you, but this is going to work. In the login template, I'm actually going to remove the login.css style sheet entirely.

Now, if you move over to your browser and find your watch tab, boom, we see an explosion. No surprises. It says, module parse failed, login.css unexpected token. It's opening login.css. That is not a JavaScript file, so webpack is exploding. Look at this message. You may need an appropriate loader to handle this file type. This is where webpack really takes a turn towards incredible. Webpack can load more than JavaScript files. In fact, it can load anything. It can load css files. It can load image files. It can load JSON files out of the box, html files, anything you want as long as you have a loader that is able to handle that. In your browser, google for css-loader and open its GitHub page. Copy the name of the library, and let's get this installed. Go over to my third terminal tab and run yarn add css-loader and also install another loader called style-loader --dev. When you're loading something that is not a JavaScript file, the job of the loader is to somehow convert that to JavaScript, which I realize still doesn't make sense, but stay with me.

Back in our webpack.config.js, we're going to add a second rule, this time with test: /\.css$/, and then use: [ 'css-loader'. We're using a shorter syntax here than the bigger loader and options, but they mean the same thing. I also want you to go into login.js and actually put a variable before the require. We'll say const css = and then console.log(css);. Because if I am telling you that somehow webpack can require css files, I'm curious. What does that mean? What will the require function actually return when we require css? Let's find out. Go over to your watch terminal, hit Control C, and rerun webpack. Check this out. There are no errors. Let's go over to the login page and refresh. First of all, the page does look really ugly. It does not work yet. No surprise, but look at the [inaudible 00:05:05]. The dump, it's actually a JavaScript array that includes all of the css rules in some sort of a string, so it's converted css into some sort of JavaScript object, which is interesting but still not very helpful.

Now, go back to your webpack.config.js and, before the 'css-loader', add 'style-loader'. Remember how I said you can have multiple loaders? In this case, we're using css-loader and style-loader. Just like with the inline syntax where you would read loaders from right to left, in this case you read the loaders from the bottom to the top. When we require any css file, it's first going to go to the css-loader, which is going to convert it to that JavaScript structure, and then it's going to go through this style-loader. What does that do? Let's find out. Go back to your watch tab and restart webpack. Now, find your browser, refresh, and what? It works. We don't have a link tag on the page, but somehow the css is actually being loaded. Notice logging an empty string, but if you inspect element and look up in the head tag you'll now find a style element with all the css. What happened is, webpack actually packaged the css into the built login.js file with some special JavaScript that said on page load add a script tag and inject the css into it. That's incredible.

Now, it does have one big downside, and that's that if you refresh and watch closely you see it's ugly for a second while the JavaScript loads, and then it looks good. This isn't really a good solution for production, but don't worry about that yet because we have a good solution for that that I'll talk about later. For now, celebrate. We can now require any dependent css from our JavaScript. I'll get rid of the console.log and the const css = part, because we don't need that. Let's do this in one other place. If you open up a components, RepLogApp, you remember this uses sweetalert, and sweetalert requires a css file. Inside app, resources, views, lift/index.html.twig, right now we're pointing to the sweetalert css file with a manual link tag. Remove that and then go back to RepLogApp.

Now, this is a little bit more interesting. We know how to include the sweetalert Javascript by saying require('sweetalert2'), but where is the css file? Does it also download a css file? Open up node_modules and go all the way down to the bottom and find sweetalert2. Inside of here is actually a dist directory with a sweetalert2.css file. We can actually say require('sweetalert2/dist/sweetalert2.css'); I'm going to talk more in a second about requiring files in this way, but for now it makes sense. We go to the sweetalert2 directory and then we just find whatever path we want after that. Now, when we head back to the Lift Stuff page and hit delete, it still looks good. Let's keep going [inaudible 00:09:44] the rest of our app to require css. We have a few surprises in store.

